<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ALMA MARINA</title>
  <style>
    html, body { margin: 0; background: #f5f5f5; }
    .wrap { max-width: 1000px; margin: 0 auto; background: #fff; }
    #viewer { line-height: 0; font-size: 0; }
    .page { position: relative; margin: 0; padding: 0; border: 0; }
    .page canvas { display: block; width: 100%; height: auto; margin: 0; padding: 0; border: 0; }
    .skeleton {
      width: 100%; height: 600px;
      background: repeating-linear-gradient(90deg,#fafafa,#fafafa 6px,#f2f2f2 6px,#f2f2f2 12px);
      animation: shimmer 1.2s linear infinite;
    }
    @keyframes shimmer { 0%{filter:brightness(1)}50%{filter:brightness(1.05)}100%{filter:brightness(1)} }
    #loader {
      position: fixed; top: 12px; right: 12px; z-index: 10;
      background: #111; color: #fff; padding: 6px 10px; border-radius: 8px;
      font: 12px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    /* ===== Botón fijo (solo CSS, sin imágenes) ===== */
    :root{
      --btn-bg:#003049;      /* fondo */
      --btn-bg-hover:#034a74;/* hover */
      --btn-fg:#ffffff;      /* texto/ícono */
    }
    .corner-btn{
      position:fixed; top:12px; left:12px; z-index:20;
      display:inline-flex; align-items:center; gap:.5rem;
      padding:10px 12px 10px 14px; border-radius:999px;
      background:var(--btn-bg); color:var(--btn-fg);
      text-decoration:none; font:600 14px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      box-shadow:0 4px 12px rgba(0,0,0,.15); border:1px solid rgba(255,255,255,.12);
    }
    .corner-btn::after{
      content:""; width:8px; height:8px;
      border:2px solid currentColor; border-left:0; border-top:0;
      transform:translateY(-1px) rotate(-45deg); transition:transform .2s ease;
    }
    .corner-btn:hover{ background:var(--btn-bg-hover); }
    .corner-btn:hover::after{ transform:translate(2px,-1px) rotate(-45deg); }
    @media (prefers-reduced-motion: reduce){
      .corner-btn::after{ transition:none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="viewer" aria-label="Visor PDF progresivo sin espacios"></div>
  </div>
  <div id="loader">Cargando…</div>

  <!-- Botón fijo: forward a versión en inglés -->
  <a class="corner-btn"
     href="https://ricardoamc.github.io/Galeria/almamarinaen.html"
     title="Ver versión en inglés"
     aria-label="View in English">
    View in English
  </a>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    // ====== Parámetros principales ======
    const PDF_URL = "https://ricardoamc.github.io/Galeria/menu-es.pdf"; 
    const DPR_PREVIEW = 1;                                  // preview rápido
    const DPR_FULL = Math.max(1, window.devicePixelRatio || 1); // mejora nítida
    const PRELOAD_PAGES = 2;                                // páginas iniciales
    const ROOT_MARGIN = "800px 0px";                        // precarga anticipada
    // --- Colapso de blancos ---
    const ENABLE_COLLAPSE = true;
    const MAX_GAP_PX = 10;          // hueco máximo permitido tras el colapso
    const WHITE_TOLERANCE = 250;    // 255=blanco puro; 250 deja margen
    const SAMPLE_STEP_X = 4;        // muestreo horizontal (↑ rápido, ↓ preciso)

    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";

    const viewer = document.getElementById("viewer");
    const loader = document.getElementById("loader");

    let pdfDoc = null;
    let renderToken = 0;                   // invalida renders en curso al redimensionar
    let containerWidth = 0;

    // Estado de cada página
    const state = new Map(); // n -> { page, previewDone, fullDone, offscreen, displayCanvas, upgrading }

    // Cola limitada para mejoras en alta densidad
    const upgradeQueue = [];
    const MAX_UPGRADES_CONCURRENT = 2;
    let runningUpgrades = 0;

    function enqueueUpgrade(fn) {
      upgradeQueue.push(fn); pumpUpgrades();
    }
    function pumpUpgrades() {
      while (runningUpgrades < MAX_UPGRADES_CONCURRENT && upgradeQueue.length) {
        const job = upgradeQueue.shift();
        runningUpgrades++;
        const schedule = window.requestIdleCallback || (cb => setTimeout(() => cb({didTimeout:false,timeRemaining:()=>0}), 0));
        schedule(async () => {
          try { await job(); } catch {}
          runningUpgrades--; pumpUpgrades();
        });
      }
    }

    // ---- Colapso: comprime huecos verticales totalmente blancos (> MAX_GAP_PX)
    function collapseVerticalWhitespace(srcCanvas, { maxGapPx = 10, whiteTol = 250, sampleStepX = 4 } = {}) {
      const w = srcCanvas.width, h = srcCanvas.height;
      if (!ENABLE_COLLAPSE || h === 0 || w === 0) return srcCanvas;

      const srcCtx = srcCanvas.getContext("2d");
      const img = srcCtx.getImageData(0, 0, w, h);
      const data = img.data;

      // Precalcular filas "en blanco"
      const blankRow = new Uint8Array(h);
      for (let y = 0; y < h; y++) {
        let isBlank = true;
        const rowOffset = y * w * 4;
        for (let x = 0; x < w; x += sampleStepX) {
          const idx = rowOffset + x * 4;
          const r = data[idx], g = data[idx+1], b = data[idx+2], a = data[idx+3];
          // Considera contenido si hay cualquier pixel "no blanco" y visible
          if (a > 0 && (r < whiteTol || g < whiteTol || b < whiteTol)) { isBlank = false; break; }
        }
        blankRow[y] = isBlank ? 1 : 0;
      }

      // Convertir en segmentos (runs) blanco / contenido
      const segments = [];
      let y = 0;
      while (y < h) {
        const curBlank = blankRow[y] === 1;
        const start = y;
        y++;
        while (y < h && (blankRow[y] === 1) === curBlank) y++;
        const len = y - start;

        if (curBlank) {
          const keep = Math.min(len, maxGapPx); // si excede, se recorta
          if (keep > 0) segments.push({ type:"blank", srcY:start, srcH:keep, dstH:keep });
          // el resto del hueco se descarta (colapsa)
        } else {
          segments.push({ type:"content", srcY:start, srcH:len, dstH:len });
        }
      }

      const outH = segments.reduce((s, seg) => s + seg.dstH, 0);
      if (outH === h) return srcCanvas; // nada que colapsar

      const outCanvas = document.createElement("canvas");
      outCanvas.width = w;
      outCanvas.height = outH;
      const outCtx = outCanvas.getContext("2d", { alpha: false });

      let dy = 0;
      for (const seg of segments) {
        outCtx.drawImage(srcCanvas, 0, seg.srcY, w, seg.srcH, 0, dy, w, seg.dstH);
        dy += seg.dstH;
      }
      return outCanvas;
    }

    async function loadPDF() {
      loader.textContent = "Cargando documento…";
      const loadingTask = pdfjsLib.getDocument({
        url: PDF_URL,
        disableAutoFetch: false,
        disableStream: false,
        rangeChunkSize: 262144 // 256KB
      });
      pdfDoc = await loadingTask.promise;

      viewer.innerHTML = "";
      containerWidth = viewer.clientWidth || window.innerWidth;

      for (let n = 1; n <= pdfDoc.numPages; n++) {
        const pageDiv = document.createElement("div");
        pageDiv.className = "page";
        pageDiv.dataset.pageNum = n;

        const skel = document.createElement("div");
        skel.className = "skeleton";
        pageDiv.appendChild(skel);
        viewer.appendChild(pageDiv);

        state.set(n, {
          page: null,
          previewDone: false,
          fullDone: false,
          offscreen: null,        // render base (sin colapso)
          displayCanvas: null,    // canvas mostrado (con colapso)
          upgrading: false
        });

        observer.observe(pageDiv);
      }

      for (let n = 1; n <= Math.min(PRELOAD_PAGES, pdfDoc.numPages); n++) {
        ensureRendered(n);
      }

      loader.textContent = `Páginas: ${pdfDoc.numPages}`;
    }

    // Renderiza a offscreen (sin colapso), luego aplica colapso y muestra
    async function renderPageToDisplay(pageNum, { dpr }) {
      const token = renderToken;
      const st = state.get(pageNum);
      if (!st) return;

      if (!st.page) st.page = await pdfDoc.getPage(pageNum);

      const baseViewport = st.page.getViewport({ scale: 1 });
      const scaleToFit = containerWidth / baseViewport.width;
      const scaledViewport = st.page.getViewport({ scale: scaleToFit * dpr });

      // Render base
      const off = document.createElement("canvas");
      off.width = Math.ceil(scaledViewport.width);
      off.height = Math.ceil(scaledViewport.height);
      const offCtx = off.getContext("2d", { alpha: false });
      await st.page.render({ canvasContext: offCtx, viewport: scaledViewport, intent: "display" }).promise;
      if (token !== renderToken) return;

      // Colapso de blancos en el render base
      const collapsed = collapseVerticalWhitespace(off, {
        maxGapPx: MAX_GAP_PX,
        whiteTol: WHITE_TOLERANCE,
        sampleStepX: SAMPLE_STEP_X
      });

      st.offscreen = off;

      // Inserta/actualiza el canvas mostrado
      const pageDiv = document.querySelector(`.page[data-page-num="${pageNum}"]`);
      if (!st.displayCanvas) {
        st.displayCanvas = document.createElement("canvas");
        pageDiv.innerHTML = "";
        pageDiv.appendChild(st.displayCanvas);
      }

      // Copia el colapsado al canvas visible (evita reflow por reemplazo de nodos)
      st.displayCanvas.width = collapsed.width;
      st.displayCanvas.height = collapsed.height;
      st.displayCanvas.style.width = (collapsed.width / dpr) + "px";
      st.displayCanvas.style.height = (collapsed.height / dpr) + "px";
      const visCtx = st.displayCanvas.getContext("2d", { alpha: false });
      visCtx.drawImage(collapsed, 0, 0);

      if (dpr === DPR_PREVIEW) st.previewDone = true; else st.fullDone = true;
    }

    async function ensureRendered(pageNum) {
      const st = state.get(pageNum);
      if (!st) return;

      if (!st.previewDone) {
        try { await renderPageToDisplay(pageNum, { dpr: DPR_PREVIEW }); } catch {}
      }
      if (!st.fullDone && !st.upgrading) {
        st.upgrading = true;
        enqueueUpgrade(async () => {
          try { await renderPageToDisplay(pageNum, { dpr: DPR_FULL }); }
          finally { st.upgrading = false; }
        });
      }
    }

    // Resize: re-renderiza sólo lo visible (vuelve a colapsar con la nueva escala)
    let resizeTimer = null;
    function onResize() {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(async () => {
        containerWidth = viewer.clientWidth || window.innerWidth;
        renderToken++;
        const visibles = getVisiblePages();
        for (const n of visibles) {
          const st = state.get(n);
          if (st) { st.previewDone = false; st.fullDone = false; }
          await ensureRendered(n);
        }
      }, 180);
    }
    window.addEventListener("resize", onResize);

    // Lazy-load con observer
    const observer = new IntersectionObserver((entries) => {
      for (const e of entries) {
        if (e.isIntersecting) {
          const n = parseInt(e.target.dataset.pageNum, 10);
          ensureRendered(n);
          if (n + 1 <= (pdfDoc?.numPages || 0)) ensureRendered(n + 1);
        }
      }
    }, { root: null, rootMargin: ROOT_MARGIN, threshold: 0.01 });

    function getVisiblePages() {
      const out = [];
      const pages = viewer.querySelectorAll(".page");
      for (const p of pages) {
        const r = p.getBoundingClientRect();
        if (r.bottom >= 0 && r.top <= window.innerHeight) {
          out.push(parseInt(p.dataset.pageNum, 10));
        }
      }
      return out;
    }

    (async () => {
      try { await loadPDF(); }
      catch (err) { console.error(err); loader.textContent = "Error al cargar el PDF"; }
    })();
  </script>
</body>
</html>
